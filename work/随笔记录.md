好嘞！！我给你直接安排一套生产级的优雅方案：
 一行 `@handle_grpc_exceptions`，自动帮你捕获异常 ➔ 正常返回 `ExecuteResponse(success=False)`，而且还能带日志！

------

# ✨ 1. 统一异常处理器：`exception_handler.py`

新建一个文件，比如叫：`services/exception_handler.py`

```python
import functools
import logging
from pb import service_pb2
from my_exceptions import InvalidParameterException, PermissionDeniedException, TimeoutException

def handle_grpc_exceptions(func):
    @functools.wraps(func)
    def wrapper(self, request, context):
        try:
            return func(self, request, context)

        except InvalidParameterException as e:
            logging.warning(f"参数错误: {e}")
            return service_pb2.ExecuteResponse(
                success=False,
                stdout="",
                stderr=f"参数错误: {str(e)}",
                exit_code=-1,
                execution_time=0,
            )

        except PermissionDeniedException as e:
            logging.warning(f"权限错误: {e}")
            return service_pb2.ExecuteResponse(
                success=False,
                stdout="",
                stderr=f"权限错误: {str(e)}",
                exit_code=-1,
                execution_time=0,
            )

        except TimeoutException as e:
            logging.warning(f"执行超时: {e}")
            return service_pb2.ExecuteResponse(
                success=False,
                stdout="",
                stderr=f"执行超时: {str(e)}",
                exit_code=-1,
                execution_time=request.timeout_seconds * 1000,
            )

        except Exception as e:
            logging.exception("ExecuteCode - 服务器内部异常")
            return service_pb2.ExecuteResponse(
                success=False,
                stdout="",
                stderr="服务器内部错误，请稍后再试。",
                exit_code=-1,
                execution_time=0,
            )

    return wrapper
```

------

# ✨ 2. 使用示例（你的 `ExecuteCodeServicer`）

超简单！！！

```python
import logging
from pb import service_pb2_grpc
from services.exception_handler import handle_grpc_exceptions

class ExecuteCodeServicer(service_pb2_grpc.ExecuteCodeServicer):

    @handle_grpc_exceptions
    def ExecuteCode(self, request, context):
        logging.info(f"收到请求: code长度={len(request.code)}, 超时={request.timeout_seconds}s")

        # 这里正常写业务逻辑
        result = run_code_in_sandbox(request.code, request.timeout_seconds)

        return service_pb2.ExecuteResponse(
            success=True,
            stdout=result.stdout,
            stderr=result.stderr,
            exit_code=result.exit_code,
            execution_time=result.execution_time,
        )
```

✅ 只需要加一行 `@handle_grpc_exceptions`
 ✅ 下面逻辑可以安心直接写，异常全自动处理成统一响应了！

------

# ✨ 3. 关于自定义异常（my_exceptions.py）

建议你单独定义一批业务异常类型，比如：

```python
# services/my_exceptions.py

class InvalidParameterException(Exception):
    """参数错误"""
    pass

class PermissionDeniedException(Exception):
    """没有权限"""
    pass

class TimeoutException(Exception):
    """执行超时"""
    pass
```

以后哪里需要抛错，比如参数校验，直接：

```python
if not request.code:
    raise InvalidParameterException("code不能为空")
```

非常优雅！

------

# 📦 总结

| 优点           | 说明                       |
| -------------- | -------------------------- |
| ✅ 统一异常处理 | 防止异常爆栈               |
| ✅ 日志完整     | logging记录所有错误        |
| ✅ 响应结构统一 | 前端永远可以拿到标准格式   |
| ✅ 代码干净     | 每个接口只有自己的业务逻辑 |
| ✅ 后期扩展方便 | 要加错误类型，只要改一处   |

------

要不要我再顺便给你拓展一版更高级的？比如加上「错误码」(`error_code`)、国际化错误提示（多语言）版本？
 如果想要，告诉我：“继续升级版！” 🚀
 我可以一键给你配到很专业那种～