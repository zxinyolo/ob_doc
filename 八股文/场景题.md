### 题目一

>你如何从零设计一个高并发下的“优惠券发放系统”，要求：
>
>- 总量不超发（比如最多 10000 张）
>- 每个用户最多领取一次
>- 支持高并发（瞬时上万请求）
>
>请说明你的设计思路、关键数据结构、是否用缓存/锁/消息队列、是否考虑幂等性与事务，以及如何验证这个方案的正确性和鲁棒性。

#### 数据结构

| 内容         | 存储  | 类型                 |
| ------------ | ----- | -------------------- |
| 优惠券总库存 | Redis | coupon_stock:int     |
| 已领取用户   | Redis | claimed_user:Set     |
| 领取记录落库 | Mysql | 表：coupon_claim_log |



#### 核心步骤

1. 请求进入后，检查用户是否已经领取（redis set）
2. 如果没有领取，执行Lua脚本判断库存是否充足，并原子减库存+添加用户ID
3. 如果成功，加入异步队列，持久化到数据库
4. 返回领取结果



### 题目2

>你维护的一个 Go 服务，在压力测试和长时间运行后，**内存持续上升**，最终导致服务响应变慢甚至 OOM（Out of Memory）。你使用 `pprof` 工具后发现 `goroutine` 数量不断上涨，可能存在**goroutine 泄露**问题。

#### 什么是 goroutine 泄露？有哪些常见的泄露场景？

goroutine 启动后**由于某些条件未满足**，导致长时间**无法退出或无法回收**，形成系统资源泄露，随着时间推移可能堆积成灾，造成**内存暴涨、调度拥堵、服务响应变慢甚至崩溃**。

**常见 goroutine 泄露场景：**

- 通道阻塞：goroutine等待从一个永远不会被写入/读出的channel读写数据，永远阻塞
- select没有case ready：select永远等待，导致协程不退出
- context没有传递或超时：启动协程未设置取消机制
- for+range channel 发送方关闭了但接收方还在等，没有退出
- goroutine中panic没有recover： 导致协程僵尸状态
- HTTP长轮询/stream没有断连机制： 一直阻塞未释放连接资源



#### 如果你怀疑一个服务存在 goroutine 泄露，你如何**定位**问题？

- 开启/debug/pprof/goroutine?debug=2：

```go
import _ "net/http/pprof"
go func() {
    http.ListenAndServe("localhost:6060", nil)
}()
```

- 使用go tool pprof分析堆栈：

```go
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

- 运行时打印goroutine栈信息（调试）：

```go
buf := make([]byte, 1<<20)
runtime.Stack(buf, true)
fmt.Printf("%s", buf)
```

- 观察进程内存、GOMAXPROCS、GC时间等指标



#### 如果定位到了泄露点，如何**修复**？请尽量给出代码示例。

- 错误示例：

  ```go
  func handler(ch chan string) {
      go func() {
          msg := <-ch // 如果没人写入 ch，这里会永久阻塞！
          fmt.Println("got:", msg)
      }()
  }
  ```

- 修复方式一：加 `select + timeout` 或 `context` 控制

  ```go
  func handler(ctx context.Context, ch chan string) {
      go func() {
          select {
          case msg := <-ch:
              fmt.Println("got:", msg)
          case <-ctx.Done():
              fmt.Println("timeout, exit goroutine")
              return
          }
      }()
  }
  ```

- 修复方式二：主协程控制退出通道（done channel）

 ```go
func startWorker(done chan struct{}) {
    go func() {
        for {
            select {
            case <-done:
                return
            default:
                // do work
            }
        }
    }()
}
 ```



#### 如何在平时开发中**预防** goroutine 泄露？

- 所有goroutine应该可控，用context.Context控制生命周期
- 避免不必要的goroutine，一些逻辑可复用复用池或复用协程
- goroutine中必须有退出条件，不应该写死死循环或阻塞语句
- 通道操作需配对，避免阻塞，有写必有读，有读必有写
- 建立自动化内存与goroutine监控机制，定期导出goroutine数量指标