### 题目一

>你如何从零设计一个高并发下的“优惠券发放系统”，要求：
>
>- 总量不超发（比如最多 10000 张）
>- 每个用户最多领取一次
>- 支持高并发（瞬时上万请求）
>
>请说明你的设计思路、关键数据结构、是否用缓存/锁/消息队列、是否考虑幂等性与事务，以及如何验证这个方案的正确性和鲁棒性。

#### 数据结构

| 内容         | 存储  | 类型                 |
| ------------ | ----- | -------------------- |
| 优惠券总库存 | Redis | coupon_stock:int     |
| 已领取用户   | Redis | claimed_user:Set     |
| 领取记录落库 | Mysql | 表：coupon_claim_log |



#### 核心步骤

1. 请求进入后，检查用户是否已经领取（redis set）
2. 如果没有领取，执行Lua脚本判断库存是否充足，并原子减库存+添加用户ID
3. 如果成功，加入异步队列，持久化到数据库
4. 返回领取结果



### 题目2

>你维护的一个 Go 服务，在压力测试和长时间运行后，**内存持续上升**，最终导致服务响应变慢甚至 OOM（Out of Memory）。你使用 `pprof` 工具后发现 `goroutine` 数量不断上涨，可能存在**goroutine 泄露**问题。

#### 什么是 goroutine 泄露？有哪些常见的泄露场景？

goroutine 启动后**由于某些条件未满足**，导致长时间**无法退出或无法回收**，形成系统资源泄露，随着时间推移可能堆积成灾，造成**内存暴涨、调度拥堵、服务响应变慢甚至崩溃**。

**常见 goroutine 泄露场景：**

- 通道阻塞：goroutine等待从一个永远不会被写入/读出的channel读写数据，永远阻塞
- select没有case ready：select永远等待，导致协程不退出
- context没有传递或超时：启动协程未设置取消机制
- for+range channel 发送方关闭了但接收方还在等，没有退出
- goroutine中panic没有recover： 导致协程僵尸状态
- HTTP长轮询/stream没有断连机制： 一直阻塞未释放连接资源



#### 如果你怀疑一个服务存在 goroutine 泄露，你如何**定位**问题？

答：加入日志，使用链路跟踪id 查看是否一直在消耗内存

#### 如果定位到了泄露点，如何**修复**？请尽量给出代码示例。

答：优雅的处理报错，资源占用采用超时处理

#### 如何在平时开发中**预防** goroutine 泄露？

答：日志写好，资源及时关闭