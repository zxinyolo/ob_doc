### 题目一

>你如何从零设计一个高并发下的“优惠券发放系统”，要求：
>
>- 总量不超发（比如最多 10000 张）
>- 每个用户最多领取一次
>- 支持高并发（瞬时上万请求）
>
>请说明你的设计思路、关键数据结构、是否用缓存/锁/消息队列、是否考虑幂等性与事务，以及如何验证这个方案的正确性和鲁棒性。

#### 数据结构

| 内容         | 存储  | 类型                 |
| ------------ | ----- | -------------------- |
| 优惠券总库存 | Redis | coupon_stock:int     |
| 已领取用户   | Redis | claimed_user:Set     |
| 领取记录落库 | Mysql | 表：coupon_claim_log |



#### 核心步骤

1. 请求进入后，检查用户是否已经领取（redis set）
2. 如果没有领取，执行Lua脚本判断库存是否充足，并原子减库存+添加用户ID
3. 如果成功，加入异步队列，持久化到数据库
4. 返回领取结果



### 题目2

>你维护的一个 Go 服务，在压力测试和长时间运行后，**内存持续上升**，最终导致服务响应变慢甚至 OOM（Out of Memory）。你使用 `pprof` 工具后发现 `goroutine` 数量不断上涨，可能存在**goroutine 泄露**问题。

#### 什么是 goroutine 泄露？有哪些常见的泄露场景？

答：goroutine 长时间运行不结束，可能存在死循环，内存回收不了，常见的泄露情景，并发处理消费者消息

#### 如果你怀疑一个服务存在 goroutine 泄露，你如何**定位**问题？

答：加入日志，使用链路跟踪id 查看是否一直在消耗内存

#### 