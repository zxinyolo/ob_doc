[TOC]



## 1. 简介
### 1.1 RabbitMQ 的特点与优势

### 1.2 消息队列的作用和应用场景

## 2. 基础概念
### 2.1 消息（Message）
### 2.2 队列（Queue）
### 2.3 交换机（Exchange）
### 2.4 绑定（Binding）
### 2.5 路由键（Routing Key）
### 2.6 消费者（Consumer）
### 2.7 生产者（Producer）
### 2.8 消息确认（Ack）
### 2.9 死信队列（Dead Letter Queue）
### 2.10 延迟队列（Delayed Queue）

## 3. RabbitMQ 架构
### 3.1 RabbitMQ 组件介绍
### 3.2 交换机类型（Direct、Fanout、Topic、Headers）
### 3.3 消息路由原理
### 3.4 持久化与非持久化消息
### 3.5 消费者确认机制

## 4. 环境搭建与配置
### 4.1 RabbitMQ 安装（Linux、Windows、Docker）
### 4.2 启动与停止 RabbitMQ 服务
### 4.3 管理控制台介绍（RabbitMQ Management）
### 4.4 用户与权限管理
### 4.5 虚拟主机（Virtual Hosts）

## 5. 核心操作示例
### 5.1 队列声明与删除
### 5.2 交换机声明与删除
### 5.3 队列与交换机绑定
### 5.4 发送消息（生产者）
### 5.5 消费消息（消费者）
### 5.6 消息确认与重试机制

## 6. 高级功能
### 6.1 死信队列配置与应用
### 6.2 延迟队列实现方式（TTL+死信队列、插件）
### 6.3 消息优先级队列
### 6.4 消息 TTL（过期时间）
### 6.5 消息持久化与事务
### 6.6 消息确认模式详解（自动 ack、手动 ack）
### 6.7 消费者限流（Prefetch Count）
### 6.8 集群与镜像队列

## 7. 典型使用场景示例
### 7.1 异步任务处理
### 7.2 流量削峰填谷
### 7.3 发布/订阅模式
### 7.4 延时任务调度
### 7.5 日志收集与处理
### 7.6 微服务消息通信

## 8. 性能与调优
### 8.1 消息吞吐量调优
### 8.2 内存和磁盘使用优化
### 8.3 连接数和通道数管理
### 8.4 消费端并发处理
### 8.5 网络延迟与故障恢复

## 9. 运维监控
### 9.1 管理控制台使用
### 9.2 RabbitMQ 命令行工具
### 9.3 日志管理
### 9.4 指标监控（Prometheus、Grafana）
### 9.5 警报与告警配置

## 10. 常见问题与排查
### 10.1 消息堆积
### 10.2 消费者不消费
### 10.3 消息重复消费
### 10.4 连接断开
### 10.5 权限问题
### 10.6 性能瓶颈

## 11. RabbitMQ 与其他技术集成
### 11.1 与 Go、Python 等语言客户端示例
### 11.2 与 Kubernetes 集成
### 11.3 与 Redis、Kafka 比较
### 11.4 使用消息队列中间件的最佳实践

## 12. 安全性
### 12.1 用户认证与授权
### 12.2 SSL/TLS 配置
### 12.3 防止消息泄露和篡改
### 12.4 安全审计

## 13. 参考资料
### 13.1 官方文档
### 13.2 社区资源
### 13.3 推荐书籍
### 13.4 常用工具与插件